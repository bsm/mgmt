#!/usr/bin/env ruby

require 'fileutils'
require 'tempfile'

module MGMT
  extend self

  DEPSFILE = "Gopherfile"
  LOCKFILE = "Gopherfile.lock"
  VENDOR   = ".vendor"
  VERSION  = "0.2.3"

  def xputs(code, msg)
    code = nil if ENV['TERM'] != "xterm"
    print "\033[#{code}m" if code
    print msg
    print "\033[0m" if code
    print "\n"
  end

  def sh(cmd)
    system(cmd) || abort("Failed to execute command: #{cmd}")
  end

  def abort(msg)
    xputs "31", ">>> #{msg}"
    Kernel.exit(1)
  end

  def read
    abort "#{DEPSFILE} not found" unless File.exist?(DEPSFILE)

    deps = Deps.parse(DEPSFILE)
    deps.merge! Deps.parse(LOCKFILE) if File.exist?(LOCKFILE)
    deps
  end

  def pull(deps)
    deps.each do |dep|
      MGMT.xputs "33",  "### #{dep.name}"
      if dep.pull!
        MGMT.xputs nil, "    now at ##{dep.tag}"
      end
    end
  end

  def lock(deps)
    deps.lock!
    MGMT.xputs "32", "=== #{LOCKFILE} written"
  end

  def exec(*c)
    ENV['GOPATH'] = "#{File.expand_path(VENDOR, ".")}:#{ENV['GOPATH']}"
    Kernel.exec *c
  end

  class Deps < Array

    def self.parse(file)
      deps = []
      File.read(file).each_line do |line|
        deps.push Dep.parse(line)
      end
      new deps.compact
    end

    def find(name)
      detect {|i| i.name == name }
    end

    def filter(names)
      self.class.new select {|i| names.include?(i.name) }
    end

    def reset!
      each do |dep|
        dep.tag = nil
      end
    end

    def merge!(locked)
      each do |dep|
        next if dep.tag

        match = locked.find(dep.name)
        dep.tag = match.tag if match
      end
    end

    def lock!
      temp = Tempfile.new LOCKFILE
      each {|d| temp.puts d.to_s }
      temp.close
      FileUtils.mv temp.path, LOCKFILE
    end

  end

  class Dep

    def self.parse(line)
      line   = line.strip
      return if line[0] == "#"

      tokens = line.split(/ +/)
      return if tokens.empty?

      opts = {}
      tokens[1..-1].each do |token|
        case token[0]
        when "!", 33
          opts[:repo] = token[1..-1]
        when "#", 35
          opts[:tag]  = token[1..-1]
        end
      end
      new tokens[0], opts
    end

    attr_reader   :name, :repo
    attr_accessor :tag

    def initialize(name, opts = {})
      @name = name
      @tag  = opts[:tag]
      @repo = opts[:repo] || "http://#{name}"
    end

    def target
      @target ||= File.join(VENDOR, 'src', @name)
    end

    def pull!
      skip = false
      if File.directory?(target)
        skip = @tag && @tag == `cd #{target} && git --git-dir=.git log -n 1 --pretty=format:'%h'`.strip
        MGMT.sh "cd #{target} && git --git-dir=.git pull -q origin master" unless skip
      else
        MGMT.sh "git clone -q #{@repo} #{target}"
      end

      @tag ||= `cd #{target} && git --git-dir=.git log -n 1 --pretty=format:'%h'`.strip
      MGMT.sh "cd #{target} && git --git-dir=.git reset -q --hard #{@tag}" unless skip
      !skip
    end

    def to_s
      "#{@name} ##{@tag} !#{@repo}"
    end
  end
end

# -------------------------------------------------------------------------

case ARGV.shift
when "install", nil
  deps = MGMT.read
  MGMT.pull(deps)
  MGMT.lock(deps)
when "go"
  MGMT.exec "go", *ARGV
when "update"
  deps = MGMT.read
  some = deps.filter(ARGV)
  unless some.empty?
    some.reset!
    MGMT.pull(some)
    MGMT.lock(deps)
  end
when "version"
  puts MGMT::VERSION
else
  puts %(mgmt is a minimalistic solution to managing Go dependencies.

Usage:

  mgmt command [arguments]

The commands are:

  install  bundle dependencies in .vendor
  go       run go within the scope of .vendor
  update   update a single package
  version  print the version
  help     print this information

)
  exit 2
end if File.basename($0) == File.basename(__FILE__)
